#include <stdio.h>
#include <stdlib.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include "modular_ops.h"
#include "ciphers/elgamal.h"

uint64_t solve_linear_congruence(uint64_t a, uint64_t b, uint64_t m) {
    uint64_t d,binv;
    d = gcd(a,m);
    if (d > 1 && b%d > 0) return 0;

    if (d > 1) {
        a = a/d;
        b = b/d;
        m = m/d;
    }

    // ax = b mod m  <==>   ab^(-1)x = bb^(-1)   <==>    ab^(-1) = 1 mod m
    // therefore x is the modulo m 
    // multiplicative inverse 
    // of a*b^(-1)
    binv = mod_inverse(b, m);
    return mod_inverse(a*binv, m);
}


int main(void) {
    uint64_t M1,M2,k;
    eg_private_key privkey;
    eg_public_key pubkey = (eg_public_key){.p=83, .g=2, .beta=47};
    eg_signature S1,S2;

    printf("ElGamal signatures can leak the private key when multiple messages are signed using the same value for k (nonce). ");
    printf("The procedure requires no bruteforcing and is the result of just formula manipolation. It's all math! ü§ì\n\n");
    printf("In this example, we will recover the private key used to sign two messages.\n");

    getchar();;

    M1 = 7;
    M2= 20;

    S1 = (eg_signature){.gamma=58, .delta=43};
    S2 = (eg_signature){.gamma=58, .delta=44};

    printf("We will use these messages:\n");
    printf("\tS1 = (M1,(Œ≥1,Œ¥1)) = (%lu,(%lu,%lu))\n",M1,S1.gamma,S1.delta);
    printf("\tS2 = (M2,(Œ≥2,Œ¥2)) = (%lu,(%lu,%lu))\n",M2,S2.gamma,S2.delta);
    printf("and public key:\n");
    printf("\t(p,g,Œ≤) = (%lu,%lu,%lu)\n",pubkey.p,pubkey.g,pubkey.beta);

    if (! elgamal_verify(M1, S1, pubkey)) {
        fprintf(stderr, "[ERR] M1 signature doesn't match the given public key\n");
        exit(0x101);
    }
    if (! elgamal_verify(M2, S2, pubkey)) {
        fprintf(stderr, "[ERR] M2 signature doesn't match the given public key\n");
        exit(0x102);
    }

    printf("\nNotice how the signatures above have the same value for Œ≥ (%lu).\n",S1.gamma);
    printf("This detail is enough to guess the same nonce value (k) was used for signing both messages.\n");
    printf("\tŒ≥1 = Œ≥2 -> g^k1 = g^k2 (mod p) -> k1 = k2 (mod p)\n");
    printf("Although this value is not known by the attacker, when k1=k2 they can easily derive with a polynomial time (!!) algorithm.\n");

    printf("\nü™Ñü™Ñ Let the magic being üßô‚Äç‚ôÇÔ∏è ü™Ñü™Ñ\n");
    
    getchar();;

    //Ensure M1 > M2 and S1 > S2
    if (M1 < M2) {
        eg_signature temp=S1;
        S1 = S2;
        S2 = temp;
        M1 = M1+M2;
        M2 = M1-M2;
        M1 = M1-M2;
    }


    printf("\nThe first step revolves around extracting the nonce from the signatures. We can do so by solving this linear congruence, for k:\n");
    printf("\t(Œ¥1-Œ¥2)*k ‚â° M1-M2 (mod (p-1))\n");
    
    // Solve for k
    // (Œ¥1-Œ¥2)*k ‚â° (M1-M2) (mod (p-1))
    // ak = b (mod m)
    uint64_t a,b,d,m,temp;

    m = (pubkey.p-1);
    a = (m+S1.delta-S2.delta) % m;
    b = (m+M1-M2+m) % m;

    d = gcd(a, m);


    printf("\t%lu*k ‚â° %lu (mod %lu)\n",a,b,m);
    //printf("GCD(%lu,%lu) = %lu possible values\n",a,m,d);
    //printf("\t%lu*k = %lu (mod %lu)\n",a/d,b/d,m/d);
    //printf("GCD(a,p-1) (%lu,%lu) is %lu\n",a,pubkey.p-1,d);
    
    k = solve_linear_congruence(a,b,m);

    // if GCD(a,m) > 1 there are 2+ possible values for k.
    // we pick the one who leads to Œ≥ = g^(k) mod p 
    // as in the public key
    for (unsigned i=0; i<d; i++) {
        k = k + i * (m/d);
        temp = modexp(pubkey.g, k, pubkey.p);
        if (temp == S1.gamma) break;
    }


    printf(">> NONCE VALUE: K = %lu\n",k);

    getchar();;

    // The private key parameter (a) can now be found by solving, 
    // for all the possible x values, the following linear congruence:
    //      Œ≥*x ‚â° (M1 - k*Œ¥1) ((mod p-1))
    //
    // There may be multiple solutions, as GCD(Œ≥,(p-1)) may not be one.
    // We can determine which one is actually the private key by checking
    // if Œ≤ ‚â° g^x (mod p) is satisfied. 

    printf("\nHaving the correct value for The private key can now be found by solving, for all the possibile x values:\n");
    printf("\tŒ≥*x ‚â° M1-k*Œ¥1 (mod (p-1))\n");
    
    // Solve for x
    // Œ≥*x = M1-k*Œ¥1 (mod (p-1))
    // ax = b (mod m)

    m = pubkey.p - 1;
    a = S1.gamma % m;
    //b = (M1 + m - k*S1.delta) % m;
    b = (M1 + m - modmul(k,S1.delta,m)) % m;

    d = gcd(a,m);

    printf("\t%lu*x = %lu (mod %lu)\n",a,b, pubkey.p-1);
    printf("and checking which one leads to Œ≤ ‚â° g^x (mod p) (which is known as a public key parameter)\n");
    printf("This congruence can have multiple solutions (mod p), because GCD(Œ≥,(p-1)) may not be 1.");
    printf("\n->\tGCD(Œ≥, (p-1)) = GCD(%lu,%lu) = %lu | %lu", a, m, d, b);

    getchar();;

    uint64_t x;

    //TODO: replace with extended euclidean algorithm
    /* for(x=1; x < m; x++) {
        if (((a/d)*x) % (m/d) == b/d) break;
    }

    temp = modexp(pubkey.g, x, pubkey.p); */
    x = solve_linear_congruence(a,b,m);
    temp = x;

    // As before, if the congruence has multiple solutions
    // we attempt to recalculate B=g^(privkey) mod p 
    // and compare the result with the B value extracted from 
    // the public key
    if (temp != pubkey.beta) {
        for(unsigned i=0; i < d; i++) {
            x = (x + (m/d)) % m;
            temp = modexp(pubkey.g, x, pubkey.p);
            if (temp == pubkey.beta) break;
        }
    }

    printf(">> x = %lu\n",x);

    printf("\nPRIVATE KEY: (x,p) = (%lu,%lu)\n",x,pubkey.p);

    getchar();;


    // Let's see if it really works!
    privkey = (eg_private_key) {.p=pubkey.p, .g=pubkey.g, .a=x};

    uint64_t M = 11;
    printf("\nWe can now forge the owner's signature. Let's try with M=%lu\n",M);

    getchar();;

    eg_signature Stest = elgamal_sign(M,privkey,9);
    printf("S3 = (%lu,(%lu,%lu))\n",M,Stest.gamma,Stest.delta);


    if (elgamal_verify(M,Stest,pubkey)) printf("SIGNATURE VERIFIED ‚úîÔ∏è\n");
    else printf("INVALID SIGNATURE ‚ùå\n");
}